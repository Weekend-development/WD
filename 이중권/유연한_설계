개방-폐쇄 원칙(Open-Closed Principle, OCP) : 확장 가능하고 변화에 유연하게 대응할 수 있는 설계원칙이다. 
`소프트웨어 객체(클래스, 모듈, 함수 등)는 확장에 열려있어야 하고, 수정에는 닫혀있어야 한다.`

* 확장에 열려 있다 : 애플리케이션의 요구사항이 변경될 때 이 변경에 맞게 새로운 `동작`을 추가해서 애플리케이션의 기능을 확장할 수 있다.
* 수정에 대해 닫혀 있다 : 기존의 `코드`를 수정하지 않고도 애플리케이션의 동작을 추가하거나 변경할 수 있다.

## 개방폐쇄 원칙의 핵심
- 추상화에 의존하는 것
`변하지 않는 부분을 고정하고 변하는 부분을 생략하는 메커니즘`
- 폐쇄를 가능하게 하는 것은 의존성의 방향

## 생성 사용 분리
- 동일한 클래스 안에서 객체 생성과 사용이 공존한다면 문제가 된다.(객체 생성이 문제가 아니라 부적절한 곳에서 객체를 생성하는 것이 문제다.
`소프트웨어 시스템은 (응용프로그램 객체를 제작하고 의존성을 서로 “연결”하는) 시작 단계와 (시작 단계 이후에 이어지는) 실행 단계를 분리해야 한다. - Martin`
- 객체 생성에 관련된 책임만을 전담하는 별도의 객체를 `FACTORY`라고 부른다. 

## 의존성 주입
외부의 독립적인 객체가 인스턴스를 생성한 후 이를 전달하여 의존성을 해결하는 방법
- 생성자 주입 : 객체를 생성하는 시점에 생성자를 통한 의존성 해결
- setteer 주입 : 객체 생성 후 setter 메서드를 통한 의존성 해결
- 메서드 주입 : 메서드 실행 시 인자를 이용한 의존성 해결

## 숨겨진 의존성은 나쁘다.
의존성 주입 이외에도 다양한 의존성 해결방법이 있는데 널리 사용되는 대표적인 방법은 SERVICE LOCATOR 패턴이다.
`SERVICE LOCATOR 패턴은 서비스를 사용하는 코드로부터 서비스가 누구인지, 어디에 있는지 몰라도 되게 해준다.`

하지만, SERVICE LOCATOR 패턴을 사용하면 의존성이 숨겨져서 클래스의 사용법을 익히기 위해 구현 내부를 모두 알아야 하여 그 클래스의 캡슐화가 무너진다.

## 의존성 역전 원칙
전통적인 절차형 프로그래밍과 의존성 방향이 반대 방향으로 나타나기 때문에 `역전`이라는 단어를 사용
- 상위 수준의 모듈은 하위 수준의 모듈에 의존해서는 안된다. (둘 모두 추상화에 의존해야 한다.)
- 추상화는 구체적인 사항에 의존해서는 안된다. 구체적인 사항은 추상화에 의존해야 한다.

## 유연성에 대한 조언
- 불필요한 유연성은 불필요한 복잡성을 낳는다. 
- 유연성은 코드를 읽는 사람들이 복잡함을 수용할 수 있을 떄 가치가 있다.

## 협력과 책임이 중요하다.
- 의존성을 관리해야 하는 이유는 역할, 책임, 협력의 관점에서 설계가 유연하고 재사용 가능해야 하기 때문이다. 
