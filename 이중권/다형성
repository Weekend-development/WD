상속의 목적은 타입 계층의 구조화 하기 위해서지 코드 재사용이 아니다.
타입 계층은 객체지향 프로그래밍의 중요한 특성인 다형성의 기반을 제공한다.

초기의 상속은 타입계층과 다형성을 구현할 수 있는 유일한 방법이었다.
하지만, 최근의 언어들은 상속 이외에 다형성을 구현할 수 있는다양한 방법들을 제공하기 떄문에 상속의 중요성능 낮아졌다.

## 다형성
- 컴퓨터 과학에서 다형성을 하나의 추상 인터페이스에 대해 코드를 작성하고 이 추상 인터페이스에 대해 서로 다른 구현을 연결할 수 있는 코드를 작성하는 방법
- 다형성은 2가지로 나눠진다.
    - 유니버셜(Universal) 다형성 : 유니버셜 안에서도 매개변수와 포함으로 나누어진다.
    - 임시(Ad Hoc) 다형성 : 임시 안에서도 오버로딩과 강제로 나누어진다.

* 오버로딩 다형성 : 하나의 클래스 안에 동일한 이름의 메서드가 존재하는 경우
* 강제 다형성 : 언어가 지원하는 자동적인 타입 변환이나 사용자가 직접 구현한 타입 변환을 이용해 동일한 연산자를 다양한 타입에 사용할 수 있는 방식 (ex: 강제 형변환)
* 매개변수 다형성 : 클래스의 인스턴스 변수나 메서드의 매개변수 타입을 임의의 타입으로 선언한 후 사용하는 시점에 구체적인 타입으로 지정하는 방식 (제네릭 프로그래밍과 관련이 높다)
* 포함 다형성 (서브타입 다형성) : 메시지가 동일하더라도 수신한 객체의 타입에 따라 실제로 수행되는 행동이 달라지는 능력 (가장 널리 알려진 형태의 다형성으로 특별한 언급이 없이 다형성이라고 하면 포함 다형성을 의미한다.)

## 상속의 양면성
- 상속의 메커니즘을 이해ㅏ기 위한 개념
    * 업캐스팅
    * 동적 메서드 탐색
    * 동적 바인딩
    * self 참조
    * super 참조

* 업캐스팅
```text
업캐스팅 : 부모 클래스 타입으로 선언된 변수에 자식 클래스의 인스턴스를 할당하는 것
다운캐스팅 : 부모 클래스의 인스턴스를 자식 클래스 타입으로 변환하기 위해서 명시적인 타입 캐스팅
```
* 동적 바인딩
```text
동적 바인딩 : 선언된 변수의 타입이 아니라 메시지를 수신하는 객체의 타입에 따라 실행된느 메서드가 결정
정적 바인딩 : 컴파일 타임에 호출할 함수를 결정하는 방식
```
## 동적 메서드 탐색과 다형성
- 메시지를 수신한 객체는 먼저 자신을 생성한 클래스에 적합한 메서드가 존재한는지 검사한다. 존재할 경우 메서드를 실행하고 탐색을 종료한다.
- 메서드를 찾지 못했다면 부모 클래스에서 메서드 탐색을 계속한다. 적합한 메서드를 찾을 때 까지 상속 계층을 따라 올라가며 계속된다.
- 상속 계층의 가장 최상위 클래스에 도달해도 메서드를 발견하지 못하면 예외를 발생시키고 탐색을 중단한다.
- self 참조 : 객체가 메시지를 수신하면 컴파일러는 self 참조라는 임시 변수를 자동으로 생성한 뒤 메시지를 수신한 객체를 가리키도록 설정 (자바에서는 this라고 부른다.)

## 포워딩과 위임
- 포워딩 : 처리를 요청할 때 self 참조를 전달하지 않는 경우
- 위임 : self 참조를 전달하는 경우 (클래스를 이용한 상속 관계를 객체 사이의 합성 관계로 대체해서 다형성을 구현하는 것)

## 객체지향
- 객체를 지향하는 것 이다. 
- 클래스는 객체를 편리하게 정의하고 생성하기 위해 제공되는 프로그래밍 구성 요소일 뿐 중요한 것은 메시지와 협력이다. 
- 클래스 없이도 객체 사이의 협력 관계를 구축하는 것이 가능하며 상속 없이도 다형성을 구현하는 것이 가능하다.

## 상속
- 포로토타입 기반의 객체지향 언어는 객체 사이의 자동적인 메시지 위임을 통해 상속을 구현 (클래스 없이도 다형성 구현)
- 중요한 것은 클래스 기반의 상속과 객체 기반의 위임 사이에 기본 개념과 메커니즘을 공유한다.
