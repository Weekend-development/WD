# 도메인
문제를 해결하기 위해 사용자가 프로그램을 사용하는 분야

## 클래스 구현하기

클래스를 구현하거나 다른 개발자에 의해 개발된 클래스를 사용할 때 가장 중요한 것은 클래스의 경계를 구분 짓는 것.

클래스의 내부와 외부를 구분해야하는 이유는 무엇일까? --> 경계의 명확성이 객체의 자율성을 보장하기 때문


### 자율적인 객체

객체는 상태(state)와 행동(behavior)을 함계 가지는 복합적인 존재라는 것.

객체는 스스로 판단하고 행동하는 자율적인 존재라는 것.

객체의 변경을 관리할 수 있는 기법 중에서 가장 대표적인 것이 바로 접근 제어 (변경될 가능성이 있는 세부적인 구현 내용을 private 영역 안에 감춤으로써 변경으로 인한 혼란을 최소화)

## 오버라이딩 과 오버로딩

오버라이딩은 부모 클래스에 정의된 같은ㅇ 이름, 같은 파라미터 목록을 가진 메서드를 자식 클래스에서 재정의하는 경우.

오버로딩은 메서드 이름은 같지만 제공되는 파라미터의 목록이 다르거나 반환값이 다른 경우.


# 상속

상속은 객체지향 코드를 재사용하기 위해 가장 널리 사용되는 방법

대부분의 사람들은 상속의 목적이 메서드나 인스턴스 변수를 재사용하는 것이라고 생각하지만 부모 클래스가 제공하는 모든 인터페이스를 자식 클래스가 물려받을 수 있음을 목적으로 한다.

따라서 자식 클래스는 상속을 통해 부모 클래스 대신 사용될 수 있다. (컴파일러는 코드 상에서 부모 클래스가 나오는 모든 장소에서 자식 클래스를 사용하는 것을 허용)

자식 클래스가 부모를 대신하는 것을 업캐스팅이라고 부른다.


# 다형성

객체지향 프로그램의 컴파일 시간 의존성과 실행 시간 의존성이 다를 수 있다느 사실을 기반으로 한다.

다형성이란 동일한 메시지를 수신했을 때 객체의 타입에 따라 다르게 응답할 수 있는 능력을 의미.

## 바인딩

메시지와 메서드를  실행 시점에 바인딩하는 것이 지연 바인딩 또는 동적 바인딩이라 한다.

전통적인 함수 호출처럼 컴파일 시점에 실행될 함수나 프로시저를 결정하는 것을 초기 바인딩 또는 정적 바인딩이라고 한ㄷ.

# 합성

상속은 캡슐화를 위반하고 설계를 유연하지 못하게 만든다.

합성은 상속이 가지는 두 가지 문제를 모두 해결한다.

인터페이스에 정의된 메시지를 통해서만 재사용이 가능하기 에 구현을 효과적으로 캡슐화 가능.

의존하는 인스턴스를 교체하는 것이 비교적 쉽기에 설계를 유연하게 만듬.


---

상속보다는 합성을 선호하는 것이 좋으나 상속을 절대 사용하지말라는 것은 아니며 대부분의 설계에서는 합성과 상속을 함께 사용해야한다.

