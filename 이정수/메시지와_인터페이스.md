## 클라이언트-서버 모델
- 협력은 어떤 객체가 다른 객체에게 무언가를 요청할 때 시작된다. -> 객체가 다른 객체에게 접근할 수 있는 유일한 방법은 메시지를 전송하는 것 뿐이다.
- 두 객체 사이의 협력 관계를 설명하기 위해 사용하는 전통적인 메타포가 클라이언트-서버 모델
  - 클라이언트 : 메시지를 전송하는 객체
  - 서버 : 메시지를 수신하는 객체
- 협력은 클라이언트가 서버의 서비스를 요청하는 단방향 상호작용이다.

## 좋은 인터페이스
- 최소한의 인터페이스 : 꼭 필요한 오퍼레이션만을 인터페이스에 포함
- 추상적인 인터페이스 : 어떻게 수행하는지가 아니라 무엇을 하는지를 표현
- 좋은 인터페이스를 설계할 수 있는 가장 좋은 방법은 책임 주도 설계 방법을 따르는 것.

## 디미터 법칙
- 객체의 내부 구조에 강하게 결합되지 않도록 협력 경로를 제한하라.
- 오직 하나의 도트만 사용하라. 단, 동일한 인스턴스를 반환하는 경우에는 해당되지 않는다.

## 묻지 말고 시켜라
- 객체의 상태에 관해 묻지 말고 원하는 것을 시켜야 한다. 즉, 메시지 전송자가 수신자의 상태를 기반으로 결정을 내린 후 메시지 수신자의 상태를 바꿔서는 안 된다.

## 설계는 트레이드오프의 산물이다. 설계를 적절하게 트레이드오프 할 수 있는 능력이 숙련자와 초보자를 구분하는 가장 중요한 기준이다.

## 명령-쿼리 분리(Command-Query Separation) 원칙
- 오퍼레이션은 부수효과(side effect)를 발생시키는 명령이거나 부수효과를 발생시키지 않는 쿼리 중 하나여야 한다
- "질문이 답변을 수정해서는 안 된다"
- 쿼리는 객체의 상태를 변경하지 않기 때문에 몇 번이고 반복적으로 호출하더라도 상관이 없다. -> 명령이 개입하지 않는 한 쿼리의 값은 변경되지 않는다. 또한 쿼리들의 순서를 자유롭게 변경할 수도 있다.
- 부수효과를 가지는 명령으로부터 부수효과를 가지지 않는 쿼리를 명백하게 분리함으로써 제한적이나마 참조 투명성의 혜택을 누릴 수 있게 된다.