# 서브클래싱과 서브타이핑

## 타입
- 개념 관점의 타입 : 우리가 인지하는 세사의 사물의 종류  
어떤 대상이 타입으로 분류 될 때 그 대상을 인스턴스라고 부른다(일반적으로 타입의 인스턴스를 객체라고 부른다)
- 프로그래밍 언어 관점의 타입 : 비트의 묶음에 의미를 부여하기 위해 정의된 제약과 규칙
    - 타입에 수행됟 수 있는 유효한 오퍼레이션의 집합을 정의
    - 타입에 수행되는 오퍼레이션에 대해 미리 약속된 문맥을 제공
- 객체지향 페러다임 관점의 타입 : 객체가 수신할 수 있는 메시지의 종류를 정의하는 것

## 타입 계층
- 타입 계층을 구성하는 두 타입 간의 관계에서 더 일반적인 타입을 슈퍼타입
- 더 특수한 타입을 서브타입이라 부른다
- 슈퍼 타입
    - 집합이 다른 집합의 모든 멤버를 포함
    - 타입 정의가 다른 타입보다 좀 더 일반적
-  서브타입
    - 집합에 포함되는 인스턴스들이 더 큰 집합에 포함
    - 타입 정의가 다른 타입보다 좀 더 구체적
- 퍼블릭 인터페이스의 관점에서 슈퍼타입과 서브타입
    - 슈퍼타입이란 서브타입이 정의한 퍼블릭 인터페이스를 일반화시켜 상대적으로 법용적이고 넓은 의미로 정의한 것
    - 서브타입이란 슈퍼타입이 정의한 퍼블릭 인터페이스를 특수화시켜 상대적으로 구체적이고 좁은 의미로 정의한 것

## 서브클래싱과 서브타이핑
- 상속의 두가지 목적이 서브클래싱과 서브타이핑이다
- 서브클래싱 : 다른 클래스의 코드를 재사용할 목적으로 상속을 사용하는 경우
- 서브타이핑 : 타입 계층을 구성하기 위해 상속을 사용하는 경우

## 계약과 서브타입
- 서브타입이 리스코프 치환원칙을 만족시키기 위해서는 클라이언트와 슈퍼타입 간에 체결된 계약을 준수해야 한다
- 어떤 타입이 슈퍼타입에서 정의한 사전조건보다 더 약한 사전조건을 정의하고 있다면 그 타입은 서브타입이 될 수 있지만 더 강한 사전조건을 정의한다면 서브타입이 될 수 없다.
- 어떤 타입이 슈퍼타입에서 정의한 사후조건보다 더 강한 사후조건을 정의하더라도 그 타입은 여전히 서브타입이지만 더 약한 사후조건을 정의한다면 서브타입 조건이 깨진다