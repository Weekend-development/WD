## 객체지향 프로그래밍을 위해 집중해야 할 것 (클래스가 아닌 객체에 초점)
- 어떤 클래스가 필요한지를 고민하기 전에 어떤 객체들이 필요한지 고민한다.(클래스는 공통적인 상태와 행동을 공유하는 객체들을 추상화한 것)
- 클래스의 윤곽을 잡기 위해 어떤 객체들이 어떤 상태와 행동을 가지는지 먼저 결정
- 객체를 독립적인 존재가 아니라 기능을 구현하기 위해 협력하는 공동체의 일원으로 봐야 한다
- 객체들의 구체적인 윤곽이 잡히면 공통 특성과 상태를 가진 객체들을 타입으로 분류하고 이 타입을 기반으로 클래스를 구현한다

## 도메인의 구조를 따르는 프로그램 구조
- 도메인 : 문제를 해결하기 위해 사용자가 프로그램을 사용하는 분야
- 객체지향 패러다임은 초기단계부터 마지막단계까지 동일한 추상화 기법을 사용한다
- 요구사항과 프로그램을 객체라는 관점에서 바라보기에 도메인을 구성하는 개념들이 프로그램 객체와 클래스로 매끄럽다

## 자율적인 객체
- 객체가 상태와 행동을 함께 하는 존재
- 객체가 스스로 판단하고 행동하는 자율적인 존재
- 캡슐화 : 데이터와 기능을 객체 내부에 한번에 묶는 것
- 외부 접근을 통제하는 접근제어와 접근 수정자를 제공한다 -> 제공 이유 : 객체를 자율적인 존재로 만들기 위해
- public interface : 외부에서 접근 가능한 부분
- 구현 : 외부 접근 불가능 오직 내부에서만 접근 가능

## 협력
- 객체가 다른 객체와 상호작용할 수 있는 방법은 메시지를 전송, 메시지 수신
- 메서드 : 수신된 메시지를 처리하기 위한 자신만의 방법

## 컴파일 시간의존성과 실행 시간 의존성
- 코드의 의존성과 실행 시점의 의존성이 서로 다를 수 있다
- 두가지가 다르면 다를수록 코드를 이해하기 어려워진다(의존성의 양면성은 트레이드오프의 산물)
- 설계가 유연해질수록 코드를 이해하고 디버깅하기는 어려워지지만, 유연성이 적어지면 재사용성과 확장 가능성이 낮아진다

## 상속과 인터페이스
- 상속 : 부모클래스가 제공하는 모든 인터페이스를 자식클래스가 물려받을 수 있다
- 인터페이스 : 객제가 이해할 수 있는 메시지 목록을 정의한다
- 구현 상속 : 순수하게 코드를 재사용하는 것
- 인터페이스 상속 : 다형적인 협력을 위해 부모클래스와 자식 클래스가 인터페이스를 공유하도록 상속을 이용
- 상속은 구현 상속이 아닌 인터페이스 상속을 위해 사용해야 한다
## 다형성
- 다형성은 컴파일 시간 의존성과 실행 시간 의존성이 다를 수 있다는 특성을 이용해 서로 다른 메서드를 실행할 수 있게 한다
- 다형성은 동일한 메시지를 수신했을 때 객체의 타입에 따라 다르게 응답할 수 있는 능력을 의미 -> 두개의 클래스의 인터페이스를 통일하기 위한 구현 방법이 상속
- 객체지향이 컴파일 시점의 의존성과 실행 시점의 의존성을 분리하고, 하나의 메시지를 선택적으로 서로 다른 메서드에 연결할 수 있는 이유가 지연 바인딩이다

## 추상화
- 추상화의 계층만 떼어 놓고 보면 요구사항의 정책을 높은 수준에서 서술할 수 있다
- 추상화를 이용하면 설계가 좀 더 유연하다 -> 설계가 구체적인 상황에 결합되는 것을 방지하기 때문(컨텍스트 독립성)

## 상속과 합성
- 상속은 캡슐화를 위반하고, 설계를 유연하지 못하게 만든다
- 합성은 인터페이스에 정의된 메시지를 통해서만 코드를 재사용하는 방법
- 결론적으로 코드의 재사용이 목적이면 합성을 다형성을 위해 인터페이스를 재사용하는 경우는 상속과 합성을 조합하여 사용

> 객체지향의 개념들을 살펴봐도, 핵심은 객체에 집중을 하자는 의미같다. 2단원 마지막 문단에 "객체지향 설계의 핵심은 적절한 협력을 식별하고 협력에 필요한 역할을 정의한 후 적절한 책임을 적절한 객체에게 할당한다"라는 글이 있다. 개인적으로 저자분 께서 강조하는 의미는 객체지향을 배웠고 객체들 간의 관련된 개념들을 상세하게 알아봤으니 적당한 관계를 조율해서 사용해야한다는 의미로 받아들여 진다.